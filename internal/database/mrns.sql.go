// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: mrns.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMrn = `-- name: CreateMrn :one
WITH upsert AS (
    INSERT INTO mrns (site_id, patient_id, mrn)
    VALUES ($1, $2, $3)
    ON CONFLICT (site_id, patient_id) DO UPDATE
    SET
        updated_at = CURRENT_TIMESTAMP,
        mrn = COALESCE(NULLIF(EXCLUDED.mrn, ''), mrns.mrn)
    WHERE mrns.mrn IS DISTINCT FROM COALESCE(NULLIF(EXCLUDED.mrn, ''), mrns.mrn)
    RETURNING id
)
SELECT id FROM upsert
UNION ALL
SELECT id FROM mrns
WHERE
    site_id = $1
    AND patient_id = $2
    AND NOT EXISTS (SELECT 1 FROM upsert)
`

type CreateMrnParams struct {
	SiteID    int32
	PatientID pgtype.Int8
	Mrn       string
}

func (q *Queries) CreateMrn(ctx context.Context, arg CreateMrnParams) (int64, error) {
	row := q.db.QueryRow(ctx, createMrn, arg.SiteID, arg.PatientID, arg.Mrn)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getMrnById = `-- name: GetMrnById :one
SELECT id, created_at, updated_at, patient_id, mrn, site_id
FROM mrns
WHERE id = $1
`

func (q *Queries) GetMrnById(ctx context.Context, id int64) (Mrn, error) {
	row := q.db.QueryRow(ctx, getMrnById, id)
	var i Mrn
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PatientID,
		&i.Mrn,
		&i.SiteID,
	)
	return i, err
}

const getMrnBySitePatient = `-- name: GetMrnBySitePatient :one
SELECT id, created_at, updated_at, patient_id, mrn, site_id
FROM mrns
WHERE
    site_id = $1
    AND patient_id = $2
`

type GetMrnBySitePatientParams struct {
	SiteID    int32
	PatientID pgtype.Int8
}

func (q *Queries) GetMrnBySitePatient(ctx context.Context, arg GetMrnBySitePatientParams) (Mrn, error) {
	row := q.db.QueryRow(ctx, getMrnBySitePatient, arg.SiteID, arg.PatientID)
	var i Mrn
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PatientID,
		&i.Mrn,
		&i.SiteID,
	)
	return i, err
}
