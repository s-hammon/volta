// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: patients.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPatient = `-- name: CreatePatient :one
WITH upsert AS (
    INSERT INTO patients (
        first_name, -- $1
        last_name, -- $2
        middle_name, -- $3
        suffix, -- $4
        prefix, -- $5
        degree, -- $6
        dob, -- $7
        sex, -- $8
        ssn, -- $9
        home_phone, -- $10
        work_phone, -- $11
        cell_phone, -- $12
        message_id -- $13
    )
    VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13
    )
    ON CONFLICT (ssn) DO UPDATE
    SET
        updated_at = CURRENT_TIMESTAMP,
        first_name = COALESCE(NULLIF(EXCLUDED.first_name, ''), patients.first_name),
        last_name = COALESCE(NULLIF(EXCLUDED.last_name, ''), patients.last_name),
        middle_name = COALESCE(NULLIF(EXCLUDED.middle_name, ''), patients.middle_name),
        suffix = COALESCE(NULLIF(EXCLUDED.suffix, ''), patients.suffix),
        prefix = COALESCE(NULLIF(EXCLUDED.prefix, ''), patients.prefix),
        degree = COALESCE(NULLIF(EXCLUDED.degree, ''), patients.degree),
        dob = EXCLUDED.dob,
        sex = EXCLUDED.sex,
        home_phone = EXCLUDED.home_phone,
        work_phone = EXCLUDED.work_phone,
        cell_phone = EXCLUDED.cell_phone,
        message_id = EXCLUDED.message_id
    WHERE
        COALESCE(NULLIF(EXCLUDED.first_name, ''), patients.first_name) IS DISTINCT FROM EXCLUDED.first_name
        OR COALESCE(NULLIF(EXCLUDED.last_name, ''), patients.last_name) IS DISTINCT FROM EXCLUDED.last_name
        OR COALESCE(NULLIF(EXCLUDED.middle_name, ''), patients.middle_name) IS DISTINCT FROM EXCLUDED.middle_name
        OR patients.suffix IS DISTINCT FROM EXCLUDED.suffix
        OR patients.prefix IS DISTINCT FROM EXCLUDED.prefix
        OR patients.degree IS DISTINCT FROM EXCLUDED.degree
        OR patients.dob IS DISTINCT FROM EXCLUDED.dob
        OR patients.sex IS DISTINCT FROM EXCLUDED.sex
        OR patients.home_phone IS DISTINCT FROM EXCLUDED.home_phone
        OR patients.work_phone IS DISTINCT FROM EXCLUDED.work_phone
        OR patients.cell_phone IS DISTINCT FROM EXCLUDED.cell_phone
    RETURNING id
)
SELECT id FROM upsert
UNION ALL
SELECT id FROM patients
WHERE
    ssn = $9
    AND NOT EXISTS (SELECT 1 FROM upsert)
`

type CreatePatientParams struct {
	FirstName  string
	LastName   string
	MiddleName pgtype.Text
	Suffix     pgtype.Text
	Prefix     pgtype.Text
	Degree     pgtype.Text
	Dob        pgtype.Date
	Sex        string
	Ssn        pgtype.Text
	HomePhone  pgtype.Text
	WorkPhone  pgtype.Text
	CellPhone  pgtype.Text
	MessageID  pgtype.Int8
}

func (q *Queries) CreatePatient(ctx context.Context, arg CreatePatientParams) (int64, error) {
	row := q.db.QueryRow(ctx, createPatient,
		arg.FirstName,
		arg.LastName,
		arg.MiddleName,
		arg.Suffix,
		arg.Prefix,
		arg.Degree,
		arg.Dob,
		arg.Sex,
		arg.Ssn,
		arg.HomePhone,
		arg.WorkPhone,
		arg.CellPhone,
		arg.MessageID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getPatientById = `-- name: GetPatientById :one
SELECT id, created_at, updated_at, first_name, last_name, middle_name, suffix, prefix, degree, dob, sex, ssn, home_phone, work_phone, cell_phone, message_id
FROM patients
WHERE id = $1
`

func (q *Queries) GetPatientById(ctx context.Context, id int64) (Patient, error) {
	row := q.db.QueryRow(ctx, getPatientById, id)
	var i Patient
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstName,
		&i.LastName,
		&i.MiddleName,
		&i.Suffix,
		&i.Prefix,
		&i.Degree,
		&i.Dob,
		&i.Sex,
		&i.Ssn,
		&i.HomePhone,
		&i.WorkPhone,
		&i.CellPhone,
		&i.MessageID,
	)
	return i, err
}

const getPatientByNameSSN = `-- name: GetPatientByNameSSN :one
SELECT id, created_at, updated_at, first_name, last_name, middle_name, suffix, prefix, degree, dob, sex, ssn, home_phone, work_phone, cell_phone, message_id
FROM patients
WHERE
    first_name = $1
    AND last_name = $2
    AND dob = $3
    AND ssn = $4
`

type GetPatientByNameSSNParams struct {
	FirstName string
	LastName  string
	Dob       pgtype.Date
	Ssn       pgtype.Text
}

func (q *Queries) GetPatientByNameSSN(ctx context.Context, arg GetPatientByNameSSNParams) (Patient, error) {
	row := q.db.QueryRow(ctx, getPatientByNameSSN,
		arg.FirstName,
		arg.LastName,
		arg.Dob,
		arg.Ssn,
	)
	var i Patient
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstName,
		&i.LastName,
		&i.MiddleName,
		&i.Suffix,
		&i.Prefix,
		&i.Degree,
		&i.Dob,
		&i.Sex,
		&i.Ssn,
		&i.HomePhone,
		&i.WorkPhone,
		&i.CellPhone,
		&i.MessageID,
	)
	return i, err
}

const updatePatient = `-- name: UpdatePatient :one
UPDATE patients
SET
    updated_at = CURRENT_TIMESTAMP,
    first_name = $2,
    last_name = $3,
    middle_name = $4,
    suffix = $5,
    prefix = $6,
    degree = $7,
    dob = $8,
    sex = $9,
    ssn = $10,
    home_phone = $11,
    work_phone = $12,
    cell_phone = $13
WHERE id = $1
RETURNING id, created_at, updated_at, first_name, last_name, middle_name, suffix, prefix, degree, dob, sex, ssn, home_phone, work_phone, cell_phone, message_id
`

type UpdatePatientParams struct {
	ID         int64
	FirstName  string
	LastName   string
	MiddleName pgtype.Text
	Suffix     pgtype.Text
	Prefix     pgtype.Text
	Degree     pgtype.Text
	Dob        pgtype.Date
	Sex        string
	Ssn        pgtype.Text
	HomePhone  pgtype.Text
	WorkPhone  pgtype.Text
	CellPhone  pgtype.Text
}

func (q *Queries) UpdatePatient(ctx context.Context, arg UpdatePatientParams) (Patient, error) {
	row := q.db.QueryRow(ctx, updatePatient,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.MiddleName,
		arg.Suffix,
		arg.Prefix,
		arg.Degree,
		arg.Dob,
		arg.Sex,
		arg.Ssn,
		arg.HomePhone,
		arg.WorkPhone,
		arg.CellPhone,
	)
	var i Patient
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstName,
		&i.LastName,
		&i.MiddleName,
		&i.Suffix,
		&i.Prefix,
		&i.Degree,
		&i.Dob,
		&i.Sex,
		&i.Ssn,
		&i.HomePhone,
		&i.WorkPhone,
		&i.CellPhone,
		&i.MessageID,
	)
	return i, err
}
