// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: procedures.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProcedure = `-- name: CreateProcedure :one
WITH upsert AS (
    INSERT INTO procedures (site_id, code, description, specialty, modality, message_id)
    VALUES ($1, $2, $3, $4, $5, $6)
    ON CONFLICT (site_id, code) DO UPDATE
    SET
        updated_at = CURRENT_TIMESTAMP,
        description = COALESCE(NULLIF(EXCLUDED.description, ''), procedures.description)
    WHERE
        COALESCE(NULLIF(EXCLUDED.description, ''), procedures.description) IS DISTINCT FROM EXCLUDED.description
    RETURNING id
)
SELECT id FROM upsert
UNION ALL
SELECT id FROM procedures
WHERE
    site_id = $1
    AND code = $2
    AND NOT EXISTS (SELECT 1 FROM upsert)
`

type CreateProcedureParams struct {
	SiteID      pgtype.Int4
	Code        string
	Description string
	Specialty   pgtype.Text
	Modality    pgtype.Text
	MessageID   pgtype.Int8
}

func (q *Queries) CreateProcedure(ctx context.Context, arg CreateProcedureParams) (int32, error) {
	row := q.db.QueryRow(ctx, createProcedure,
		arg.SiteID,
		arg.Code,
		arg.Description,
		arg.Specialty,
		arg.Modality,
		arg.MessageID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getProcedureById = `-- name: GetProcedureById :one
SELECT id, created_at, updated_at, site_id, code, description, specialty, modality, message_id, updated_by
FROM procedures
WHERE id = $1
`

func (q *Queries) GetProcedureById(ctx context.Context, id int32) (Procedure, error) {
	row := q.db.QueryRow(ctx, getProcedureById, id)
	var i Procedure
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SiteID,
		&i.Code,
		&i.Description,
		&i.Specialty,
		&i.Modality,
		&i.MessageID,
		&i.UpdatedBy,
	)
	return i, err
}

const getProcedureBySiteIDCode = `-- name: GetProcedureBySiteIDCode :one
SELECT id, created_at, updated_at, site_id, code, description, specialty, modality, message_id, updated_by
FROM procedures
WHERE
    site_id = $1
    AND code = $2
`

type GetProcedureBySiteIDCodeParams struct {
	SiteID pgtype.Int4
	Code   string
}

func (q *Queries) GetProcedureBySiteIDCode(ctx context.Context, arg GetProcedureBySiteIDCodeParams) (Procedure, error) {
	row := q.db.QueryRow(ctx, getProcedureBySiteIDCode, arg.SiteID, arg.Code)
	var i Procedure
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SiteID,
		&i.Code,
		&i.Description,
		&i.Specialty,
		&i.Modality,
		&i.MessageID,
		&i.UpdatedBy,
	)
	return i, err
}

const getProceduresForModalityUpdate = `-- name: GetProceduresForModalityUpdate :many
SELECT id, created_at, updated_at, site_id, code, description, specialty, modality, message_id, updated_by
FROM procedures
WHERE
    modality is null
    AND id > $1
ORDER BY id -- so one can move cursor value $1 to max(id)
LIMIT 100
`

func (q *Queries) GetProceduresForModalityUpdate(ctx context.Context, id int32) ([]Procedure, error) {
	rows, err := q.db.Query(ctx, getProceduresForModalityUpdate, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Procedure
	for rows.Next() {
		var i Procedure
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SiteID,
			&i.Code,
			&i.Description,
			&i.Specialty,
			&i.Modality,
			&i.MessageID,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProceduresForSpecialtyUpdate = `-- name: GetProceduresForSpecialtyUpdate :many
SELECT id, created_at, updated_at, site_id, code, description, specialty, modality, message_id, updated_by
FROM procedures
WHERE
    specialty is null
    AND id > $1
ORDER BY id -- so one can move cursor value $1 to max(id)
LIMIT 100
`

func (q *Queries) GetProceduresForSpecialtyUpdate(ctx context.Context, id int32) ([]Procedure, error) {
	rows, err := q.db.Query(ctx, getProceduresForSpecialtyUpdate, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Procedure
	for rows.Next() {
		var i Procedure
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SiteID,
			&i.Code,
			&i.Description,
			&i.Specialty,
			&i.Modality,
			&i.MessageID,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProcedureModality = `-- name: UpdateProcedureModality :exec
UPDATE procedures
SET modality = $2
WHERE id = $1
`

type UpdateProcedureModalityParams struct {
	ID       int32
	Modality pgtype.Text
}

func (q *Queries) UpdateProcedureModality(ctx context.Context, arg UpdateProcedureModalityParams) error {
	_, err := q.db.Exec(ctx, updateProcedureModality, arg.ID, arg.Modality)
	return err
}

const updateProcedureSpecialty = `-- name: UpdateProcedureSpecialty :exec
UPDATE procedures
SET specialty = $2
WHERE id = $1
`

type UpdateProcedureSpecialtyParams struct {
	ID        int32
	Specialty pgtype.Text
}

func (q *Queries) UpdateProcedureSpecialty(ctx context.Context, arg UpdateProcedureSpecialtyParams) error {
	_, err := q.db.Exec(ctx, updateProcedureSpecialty, arg.ID, arg.Specialty)
	return err
}
